1.哈希表
是一种数据结构，核心目的是建立键值对的映射关系，实现元素的增删改查。
它之所以高效，是因为它使用了哈希函数和数组。
哈希函数：将任意大小、任意类型的键，通过计算，映射成一个固定范围的整数。这个整数就是键值对在数组中索引地址。index = hash function(key);这个函数的时间复杂度是O(1)
数组：哈希表底层是一个数组，系统只需要计算出index，然后直接访问数组的index位置。
冲突：
理论上一个key一个index.
实际上键的数量大于底层数组的长度，不同的键会计算出相同的index.这就是哈希冲突。
解决策略：
链地址法chaining：在数组的每个桶中，不是直接存值，而是存一个链表或平衡树。
一个具体的例子
假设我们有两个键 key1 和 key2：

key1.hashCode() == key2.hashCode() // 返回 true，假设哈希值都是 12345

key1.equals(key2) // 返回 false

HashMap的存储过程：

key1 先被存入。计算出的索引是 5。数组位置5目前是空的，所以直接创建一个Node存放 (key1, value1)。

key2 接着被存入。计算出的索引也是 5。HashMap发现位置5已经有元素了。

HashMap开始遍历位置5的链表：

第一个节点是 (key1, value1)。

比较哈希：12345 == 12345 -> true。

比较键：先用 == 比较，key1 == key2 -> false；再用 equals 比较，key1.equals(key2) -> false。

所以，key2 不等于 key1。

由于链表下一个节点是 null（目前只有一个元素），遍历结束。

HashMap将 (key2, value2) 作为一个新的Node，添加到链表中。

最终，在数组索引为5的位置，形成了一个链表：
[ (key1, value1) ] -> [ (key2, value2) ] -> null


HashMap:用键的hashCode方法计算hash值，再通过某种算法得到index.(某种算法：7-indexFor,8-(n-1)&hash).(hash值：经过扰动处理，防止hash值分配不均，从而减少冲突)
扩容：默认容量：16,负载因子0.75. 16*0.75=12,当数组中元素数量超过12，就会触发扩容。
扩容做了什么：新建数组，长度是原来的2倍.重新计算阙值32*0.75=24.重新hash:变量每个元素，重新计算hash及index,将元素迁到对应的位置。当元素很多时，这是一个耗费性能的过程，建议提前就计算好容量。
链表和红黑色转化：链表长度超过8转为红黑树。红黑树元素少于6转为链表。（红黑树：子平衡的搜索二叉树）。
7-头插法，多线程时可能形成环。

hashCode和equals
HashMap的键必须实现hashCode和equals。
### HashMap 键值判断与处理方式

| 场景 | HashMap 的处理方式 |
| :--- | :--- |
| **hashCode 不同** | 大概率存放在数组的不同位置。 |
| **hashCode 相同，equals 为 true** | 视为同一个键，用新值覆盖旧值。 |
| **hashCode 相同，equals 为 false** | 视为不同的键，在同一个数组位置形成链表（或红黑树）。 |

